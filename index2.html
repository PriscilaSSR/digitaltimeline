<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple 3D Timeline Universe</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      background-color: #000;
      color: #fff;
    }
    
    #container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
    }
    
    .btn {
      background-color: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div class="controls">
    <button id="zoom-in" class="btn">Zoom In</button>
    <button id="zoom-out" class="btn">Zoom Out</button>
    <button id="reset" class="btn">Reset View</button>
  </div>

  <!-- Load Three.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Sample timeline data structure (you can replace this with your timelineData.js)
    const timelineItems = [
      {
        title: "First Telegraph",
        date: "1844",
        category: "Engineering Experiments & Demonstrations",
        connections: ["Telephone Invention"]
      },
      {
        title: "Telephone Invention",
        date: "1876",
        category: "Engineering Experiments & Demonstrations",
        connections: ["Radio Transmission"]
      },
      {
        title: "Radio Transmission",
        date: "1895",
        category: "Engineering Experiments & Demonstrations",
        connections: []
      },
      {
        title: "Information Theory",
        date: "1948",
        category: "Conceptual & Scientific Breakthroughs",
        connections: ["Internet Development"]
      },
      {
        title: "Internet Development",
        date: "1969",
        category: "Conceptual & Scientific Breakthroughs",
        connections: ["World Wide Web"]
      },
      {
        title: "World Wide Web",
        date: "1989",
        category: "Conceptual & Scientific Breakthroughs",
        connections: []
      },
      {
        title: "First Smartphone",
        date: "2007",
        category: "Sociocultural Factors",
        connections: ["Social Media Growth"]
      },
      {
        title: "Social Media Growth",
        date: "2010",
        category: "Sociocultural Factors",
        connections: []
      }
    ];

    // Initialize the scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    // Initialize the camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.z = 1000;

    // Initialize the renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    scene.add(directionalLight);

    // Add controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Add stars to the background
    const starsGeometry = new THREE.BufferGeometry();
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 1,
      sizeAttenuation: false
    });

    const starsVertices = [];
    for (let i = 0; i < 2000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starsVertices.push(x, y, z);
    }

    starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    const starField = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(starField);

    // Define the orbital shells
    const categories = [
      {
        name: "Engineering Experiments & Demonstrations",
        radius: 300,
        color: 0x2e7d32 // green
      },
      {
        name: "Conceptual & Scientific Breakthroughs",
        radius: 600,
        color: 0x1565c0 // blue
      },
      {
        name: "Sociocultural Factors",
        radius: 900,
        color: 0xc62828 // red
      }
    ];

    // Create orbital rings
    categories.forEach(category => {
      const ringGeometry = new THREE.TorusGeometry(category.radius, 2, 16, 100);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: category.color,
        transparent: true,
        opacity: 0.5,
        wireframe: true
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      scene.add(ring);
    });

    // Count connections for sizing
    const connectionCounts = new Map();
    timelineItems.forEach(item => {
      // Count outgoing connections
      const outConnections = item.connections ? item.connections.length : 0;
      
      // Count incoming connections
      let inConnections = 0;
      timelineItems.forEach(otherItem => {
        if (otherItem.connections && otherItem.connections.includes(item.title)) {
          inConnections++;
        }
      });
      
      // Store total connections
      connectionCounts.set(item.title, outConnections + inConnections);
    });

    const maxConnections = Math.max(1, ...connectionCounts.values());

    // Create the nodes
    timelineItems.forEach(item => {
      const categoryInfo = categories.find(cat => cat.name === item.category);
      if (!categoryInfo) return;
      
      // Get random position on the orbital shell
      const phi = Math.random() * Math.PI * 2;
      const theta = Math.random() * Math.PI;
      const radius = categoryInfo.radius;
      
      const x = radius * Math.sin(theta) * Math.cos(phi);
      const y = radius * Math.sin(theta) * Math.sin(phi);
      const z = radius * Math.cos(theta);
      
      // Scale node size based on connections
      const connectionCount = connectionCounts.get(item.title) || 0;
      const baseSize = 10;
      const minSize = baseSize * 0.8;
      const maxSize = baseSize * 3;
      const scaledSize = minSize + ((maxSize - minSize) * (connectionCount / maxConnections));
      
      // Create the sphere
      const geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        color: categoryInfo.color,
        emissive: categoryInfo.color,
        emissiveIntensity: 0.2,
        shininess: 30
      });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.set(x, y, z);
      scene.add(sphere);
      
      // Create a label for the sphere
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 128;
      context.fillStyle = '#ffffff';
      context.font = '24px Arial';
      context.fillText(item.title, 10, 34);
      context.font = '18px Arial';
      context.fillText(item.date, 10, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      const labelMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true
      });
      const label = new THREE.Sprite(labelMaterial);
      label.position.set(x, y + scaledSize + 20, z);
      label.scale.set(100, 50, 1);
      scene.add(label);
    });

    // Draw connections between nodes
    timelineItems.forEach(item => {
      if (!item.connections || item.connections.length === 0) return;
      
      const sourcePosition = getNodePosition(item.title);
      if (!sourcePosition) return;
      
      item.connections.forEach(targetTitle => {
        const targetPosition = getNodePosition(targetTitle);
        if (!targetPosition) return;
        
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0xaaaaaa,
          transparent: true,
          opacity: 0.6
        });
        
        const points = [];
        points.push(new THREE.Vector3(sourcePosition.x, sourcePosition.y, sourcePosition.z));
        points.push(new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z));
        
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
      });
    });

    // Helper function to get node position by title
    function getNodePosition(title) {
      const item = timelineItems.find(item => item.title === title);
      if (!item) return null;
      
      const categoryInfo = categories.find(cat => cat.name === item.category);
      if (!categoryInfo) return null;
      
      // We need to recalculate the position using the same algorithm
      // This is a simplification - in a real app, you'd store these positions
      const phi = Math.random() * Math.PI * 2;
      const theta = Math.random() * Math.PI;
      const radius = categoryInfo.radius;
      
      return {
        x: radius * Math.sin(theta) * Math.cos(phi),
        y: radius * Math.sin(theta) * Math.sin(phi),
        z: radius * Math.cos(theta)
      };
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Add button event listeners
    document.getElementById('zoom-in').addEventListener('click', () => {
      camera.position.multiplyScalar(0.8);
    });

    document.getElementById('zoom-out').addEventListener('click', () => {
      camera.position.multiplyScalar(1.2);
    });

    document.getElementById('reset').addEventListener('click', () => {
      camera.position.set(0, 0, 1000);
      camera.lookAt(0, 0, 0);
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>

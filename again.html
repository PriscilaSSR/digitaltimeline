<!DOCTYPE html>
<html>
<head>
  <title>Flight History: Venn Diagram & Network Graph</title>
  <style>
    /* Container for responsiveness */
    #visualization-container {
      width: 100%;          /* Fill available width */
      padding-bottom: 75%;  /* Maintain 4:3 aspect ratio (height = 75% of width) */
      position: relative;  /* Needed for absolute positioning of SVG */
    }

    #visualization {
      position: absolute; /* Take SVG out of normal flow */
      top: 0;
      left: 0;
      width: 100%;       /* Fill container */
      height: 100%;      /* Fill container */
    }

    .venn-circle {
      opacity: 0.5;
      cursor: pointer;
    }

    .node {
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: pointer;
    }

    /* Dynamic link width and node size*/
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
      /*stroke-width: calc(0.5px + 0.5vw);*/ /* Responsive stroke width */
    }


    #tooltip {
      position: absolute;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      font-family: sans-serif;
      font-size: 12px;
      pointer-events: none;
      display: none;
    }
    .node.highlighted {
      stroke: black;
      stroke-width: 3px;
    }
    .link.highlighted {
        stroke: black;
        /*stroke-width: 2px;*/
    }
  </style>
</head>
<body>

<div id="tooltip"></div>
<div id="visualization-container">
  <svg id="visualization"></svg>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/venn.js/0.2.20/venn.min.js"></script>
<script src="timelineData.js"></script> <script>

// --- Data Loading (Already Done) ---

// --- Venn Diagram Setup ---

// Prepare data for Venn.js (same as before)
const vennData = [
  { sets: ['SF'], size: 0, label: 'Sociocultural Factors' },
  { sets: ['CSB'], size: 0, label: 'Conceptual & Scientific Breakthroughs' },
  { sets: ['EED'], size: 0, label: 'Engineering Experiments & Demonstrations' },
  { sets: ['SF', 'CSB'], size: 0 },
  { sets: ['CSB', 'EED'], size: 0 },
  { sets: ['SF', 'EED'], size: 0 },
  { sets: ['SF', 'CSB', 'EED'], size: 0 },
];

timelineItems.forEach(item => {
  const groups = item.group.split('-');
  let region = null;
  if (groups.length === 1) {
    region = vennData.find(r => r.sets.length === 1 && r.sets[0] === item.group);
  } else if (groups.length === 2) {
    region = vennData.find(r => r.sets.length === 2 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]));
  } else if (groups.length === 3) {
    region = vennData.find(r => r.sets.length === 3 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]) && r.sets.includes(groups[2]));
  }

  if (region) {
    region.size += 1;
  }
});

// Get container dimensions (for responsiveness)
const container = document.getElementById("visualization-container");
const width = container.clientWidth;
const height = container.clientHeight; // Height is now based on the container

// Create Venn diagram
const vennChart = venn.VennDiagram().width(width * 0.5).height(height); // Venn diagram takes half the width

const vennSvg = d3.select("#visualization")
  .datum(vennData)
  .call(vennChart);

d3.selectAll(".venn-label").remove(); // Remove labels


// --- Network Graph Setup ---

const nodes = timelineItems.map(item => ({
  id: item.title,
  group: item.group,
  ...item
}));

const links = [];
timelineItems.forEach(item => {
  if (item.connections) {
    item.connections.forEach(target => {
      if (nodes.find(n => n.id === target)) {
        links.push({ source: item.title, target: target, value: 1 });
      }
    });
  }
});

const svg = d3.select("#visualization");

// Create simulation *without* a center force initially
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(width * 0.08)) // Responsive distance
    .force("charge", d3.forceManyBody().strength(-50))
    .force("collision", d3.forceCollide().radius(width * 0.015)) // Responsive radius
    .on("tick", ticked);

// --- Custom Venn Force ---

function customVennForce() {
    const strength = 0.1;

  function getVennRegionCenter(sets) {
        const vennArea = d3.selectAll(".venn-area");
        if (!sets || sets.length === 0) {
            return { x: width / 2, y: height / 2 }; // Default center if no sets
        }

        if (sets.length === 1) {
          // Single circle centers
            const circle = vennArea.filter(d => d.sets.length === 1 && d.sets[0] === sets[0]).select("path");
            if (!circle.empty()) {
                const bounds = circle.node().getBBox();
                return { x: bounds.x + bounds.width / 2, y: bounds.y + bounds.height / 2 };
            }
        }

        // Approximate center for intersections
        const region = vennArea.filter(d => {
            return d.sets.length === sets.length && sets.every(s => d.sets.includes(s));
        });

        if (!region.empty()) {
             const bounds = region.node().getBBox(); //D3 selections have method .node()
             return { x: bounds.x + bounds.width/2, y: bounds.y + bounds.height/2};
        }


        return { x: width / 2, y: height / 2 }; // Default
    }

  function force(alpha) {
    nodes.forEach(node => {
      const groups = node.group.split('-');
      const target = getVennRegionCenter(groups);
      if (target) {
        node.vx += (target.x - node.x) * strength * alpha;
        node.vy += (target.y - node.y) * strength * alpha;
      }
    });
  }

  return force;
}
simulation.force("venn", customVennForce());


// --- Node and Link Creation ---
const link = svg.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(links)
    .enter().append("line")
    .attr("class", "link")
    .attr("stroke-width", d => Math.sqrt(d.value) + 0.15 * (width/800)); //Responsive width


const node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", width * 0.01) // Responsive radius
    .attr("fill", d => {
        const groups = d.group.split('-');
        if (groups.includes('SF')) return "red";
        if (groups.includes('CSB')) return "blue";
        if (groups.includes('EED')) return "green";
        return "gray";
    })
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended))
  .on("mouseover", handleMouseOver)
  .on("mouseout", handleMouseOut)
  .on("click", handleClick);


// --- Tooltip and Highlighting Functions (No changes needed) ---
const tooltip = d3.select("#tooltip");

function handleMouseOver(event, d) {
  tooltip.style("display", "block")
    .html(`
      <strong>${d.title}</strong><br>
      Date: ${d.date}<br>
      Category: ${d.category}<br>
      Description: ${d.description}
    `)
    .style("left", (event.pageX + 10) + "px")
    .style("top", (event.pageY - 28) + "px");
  highlightConnections(d);
}

function handleMouseOut() {
  tooltip.style("display", "none");
  resetHighlight();
}

function handleClick(event, d) {
  // alert(d.description); // Or show details in a different way
    tooltip.style("display", "block")
    .html(`
        <strong>${d.title}</strong><br>
        Date: ${d.date}<br>
        Category: ${d.category}<br>
        Description: ${d.description}
    `)
    .style("left", (event.pageX + 10) + "px")
    .style("top", (event.pageY - 28) + "px");

    // Highlight connected nodes and links
    highlightConnections(d);
}


function highlightConnections(d) {
  const connectedNodeIds = new Set();
  links.forEach(l => {
    if (l.source.id === d.id) connectedNodeIds.add(l.target.id);
    if (l.target.id === d.id) connectedNodeIds.add(l.source.id);
  });

  node.classed("highlighted", n => connectedNodeIds.has(n.id) || n.id === d.id);
  link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id);
}

function resetHighlight() {
  node.classed("highlighted", false);
  link.classed("highlighted", false);
}


// --- Initial Node Positioning (within Venn regions) ---
nodes.forEach(node => {
  const groups = node.group.split('-');
  const regionCenter = getVennRegionCenter(groups);
    if (regionCenter) {
    // Initial random position *around* the region center
    node.x = regionCenter.x + (Math.random() - 0.5) * 50; // Adjust range as needed
    node.y = regionCenter.y + (Math.random() - 0.5) * 50;
  } else {
    // Default position if no region found (shouldn't happen with correct data)
    node.x = width / 2;
    node.y = height / 2;
  }

});


// --- Tick Function ---

function ticked() {
  link
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

  node
    .attr("cx", d => d.x)
    .attr("cy", d => d.y);
}

// --- Interactivity (Venn -> Network) ---
d3.selectAll(".venn-area").on("click", function(event, d) {
  const selectedSets = d.sets;

    node.style("opacity", n => {
    const nodeGroups = n.group.split('-');
    return selectedSets.every(set => nodeGroups.includes(set)) ? 1 : 0.1;
  });

  link.style("stroke-opacity", l => {
    const sourceGroups = l.source.group.split('-');
    const targetGroups = l.target.group.split('-');
    const sourceMatch = selectedSets.every(set => sourceGroups.includes(set));
    const targetMatch = selectedSets.every(set => targetGroups.includes(set));
    return sourceMatch && targetMatch ? 1 : 0.1;
  });
});


// --- Drag Functions ---

function dragstarted(event) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  event.subject.fx = event.subject.x;
  event.subject.fy = event.subject.y;
}

function dragged(event) {
  event.subject.fx = event.x;
  event.subject.fy = event.y;
}

function dragended(event) {
  if (!event.active) simulation.alphaTarget(0);
  event.subject.fx = null;
  event.subject.fy = null;
}

</script>

</body>
</html>

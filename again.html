<!DOCTYPE html>
<html>
<head>
  <title>Flight History: Venn Diagram & Network Graph</title>
  <style>
    .venn-circle {
      opacity: 0.5;
      cursor: pointer; /* Indicate clickability */
    }
    /* Remove Venn labels */
    /*.venn-label { font-family: sans-serif; font-size: 14px; text-anchor: middle; pointer-events: none;}*/
    .node {
      stroke: #fff;
      stroke-width: 1.5px;
      cursor: pointer; /* Indicate clickability */
    }
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    #tooltip {
      position: absolute;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      font-family: sans-serif;
      font-size: 12px;
      pointer-events: none; /* Important! */
      display: none; /* Initially hidden */
    }
    /* Style for highlighted nodes */
    .node.highlighted {
      stroke: black;
      stroke-width: 3px;
    }
    /* Style for highlighted links */
    .link.highlighted {
        stroke: black;
        stroke-width: 2px;
    }


  </style>
</head>
<body>

<div id="tooltip"></div>
<svg width="800" height="600" id="visualization"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/venn.js/0.2.20/venn.min.js"></script>
<script src="timelineData.js"></script>
 <script>
const data = window.timelineItems;
// Prepare data for Venn.js, counting items in each group.
const vennData = [
  { sets: ['SF'], size: 0, label: 'Sociocultural Factors' },
  { sets: ['CSB'], size: 0, label: 'Conceptual & Scientific Breakthroughs' },
  { sets: ['EED'], size: 0, label: 'Engineering Experiments & Demonstrations' },
  { sets: ['SF', 'CSB'], size: 0, label: 'SF ∩ CSB' },
  { sets: ['CSB', 'EED'], size: 0, label: 'CSB ∩ EED' },
  { sets: ['SF', 'EED'], size: 0, label: 'SF ∩ EED' },
  { sets: ['SF', 'CSB', 'EED'], size: 0, label: 'SF ∩ CSB ∩ EED' },
];

timelineItems.forEach(item => {
    const groups = item.group.split('-');
    let region = null;
    if (groups.length === 1) {
        region = vennData.find(r => r.sets.length === 1 && r.sets[0] === item.group);
    } else if (groups.length === 2) {
        region = vennData.find(r => r.sets.length === 2 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]));
    } else if (groups.length === 3) {
        region = vennData.find(r => r.sets.length === 3 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]) && r.sets.includes(groups[2]));
    }

    if (region) {
        region.size += 1;
    }
});

// --- Venn Diagram ---

// Prepare data for Venn.js, counting items in each group.
const vennData = [
  { sets: ['SF'], size: 0, label: 'Sociocultural Factors' },
  { sets: ['CSB'], size: 0, label: 'Conceptual & Scientific Breakthroughs' },
  { sets: ['EED'], size: 0, label: 'Engineering Experiments & Demonstrations' },
  { sets: ['SF', 'CSB'], size: 0, label: 'SF ∩ CSB' },
  { sets: ['CSB', 'EED'], size: 0, label: 'CSB ∩ EED' },
  { sets: ['SF', 'EED'], size: 0, label: 'SF ∩ EED' },
  { sets: ['SF', 'CSB', 'EED'], size: 0, label: 'SF ∩ CSB ∩ EED' },
];

timelineItems.forEach(item => {
    const groups = item.group.split('-');
    let region = null;
    if (groups.length === 1) {
        region = vennData.find(r => r.sets.length === 1 && r.sets[0] === item.group);
    } else if (groups.length === 2) {
        region = vennData.find(r => r.sets.length === 2 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]));
    } else if (groups.length === 3) {
        region = vennData.find(r => r.sets.length === 3 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]) && r.sets.includes(groups[2]));
    }

    if (region) {
        region.size += 1;
    }
});

// Create Venn diagram (will be used for positioning nodes)
const vennChart = venn.VennDiagram()
  .width(400)
  .height(400);

const vennSvg = d3.select("#visualization")
  .datum(vennData)
  .call(vennChart);

// Remove the labels
d3.selectAll(".venn-label").remove()

// --- Network Graph ---

const nodes = timelineItems.map(item => ({
  id: item.title,
  group: item.group,
  ...item
}));

const links = [];
timelineItems.forEach(item => {
  if (item.connections) {
    item.connections.forEach(target => {
      if (nodes.find(n => n.id === target)) {
        links.push({ source: item.title, target: target, value: 1 });
      }
    });
  }
});

const svg = d3.select("#visualization"); // No need to append another 'g'

const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(50))
    .force("charge", d3.forceManyBody().strength(-50)) // Reduced charge
    .force("center", d3.forceCenter(400, 300)) // Centered in the SVG
    .force("collision", d3.forceCollide().radius(12)) // Increased collision radius
    .on("tick", ticked); // Move ticked function here


// --- Custom Venn Force ---
function customVennForce() {
  const strength = 0.1; // Adjust force strength

  function getVennRegionCenter(sets) {
      if (!sets || sets.length === 0) {
        return { x: 400, y: 300 }; // Default center if no sets
    }

      if (sets.length === 1) {
          // Single circle centers
          if (sets[0] === 'SF') return { x: 158, y: 245 };
          if (sets[0] === 'CSB') return { x: 242, y: 245 };
          if (sets[0] === 'EED') return { x: 200, y: 155 };
      }

      // Approximate center for intersections - using bounding box intersection centers
      let xSum = 0;
      let ySum = 0;
      let count = 0;

    if (sets.length === 2) {
          if (sets.includes("SF") && sets.includes("CSB")) return {x: 200, y: 265};
          if (sets.includes("SF") && sets.includes("EED")) return {x: 177, y: 200};
          if (sets.includes("CSB") && sets.includes("EED")) return {x: 230, y: 200};
    }
    if(sets.length === 3){
        return {x:200, y: 200}
    }
  }

  function force(alpha) {
    nodes.forEach(node => {
      const groups = node.group.split('-');
      const target = getVennRegionCenter(groups);
      if (target) {
          // Use .x and .y directly, no need for dx, dy
          node.vx += (target.x - node.x) * strength * alpha;
          node.vy += (target.y - node.y) * strength * alpha;
      }
    });
  }

  return force;
}
// Add the custom force to the simulation
simulation.force("venn", customVennForce());


// --- Node and Link Creation --- (Modified for initial positioning)

const link = svg.append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(links)
    .enter().append("line")
    .attr("class", "link")
     .attr("stroke-width", d => Math.sqrt(d.value));

const node = svg.append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("r", 8)
    .attr("fill", d => {
        const groups = d.group.split('-');
        if (groups.includes('SF')) return "red";
        if (groups.includes('CSB')) return "blue";
        if (groups.includes('EED')) return "green";
        return "gray";
    })
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended))
  .on("mouseover", handleMouseOver) // Use named functions for clarity
  .on("mouseout", handleMouseOut)
  .on("click", handleClick);  // Add click handler



// --- Tooltip and Highlighting Functions ---

const tooltip = d3.select("#tooltip");

function handleMouseOver(event, d) {
  tooltip.style("display", "block")
    .html(`
      <strong>${d.title}</strong><br>
      Date: ${d.date}<br>
      Category: ${d.category}<br>
      Description: ${d.description}
    `)
    .style("left", (event.pageX + 10) + "px")
    .style("top", (event.pageY - 28) + "px");

  // Highlight connected nodes and links
  highlightConnections(d);
}

function handleMouseOut() {
  tooltip.style("display", "none");
  resetHighlight();
}

function handleClick(event, d){
    //alert(d.description);
    tooltip.style("display", "block")
    .html(`
        <strong>${d.title}</strong><br>
        Date: ${d.date}<br>
        Category: ${d.category}<br>
        Description: ${d.description}
    `)
    .style("left", (event.pageX + 10) + "px")
    .style("top", (event.pageY - 28) + "px");

    // Highlight connected nodes and links
    highlightConnections(d);
}

function highlightConnections(d) {
  const connectedNodeIds = new Set();
  links.forEach(l => {
    if (l.source.id === d.id) connectedNodeIds.add(l.target.id);
    if (l.target.id === d.id) connectedNodeIds.add(l.source.id);
  });

  node.classed("highlighted", n => connectedNodeIds.has(n.id) || n.id === d.id);
  link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id);
}

function resetHighlight() {
  node.classed("highlighted", false);
  link.classed("highlighted", false);
}

// --- Initial Node Positioning (within Venn regions) ---

nodes.forEach(node => {
  const groups = node.group.split('-');
  const regionCenter = getVennRegionCenter(groups);

  if (regionCenter) {
    // Initial random position *around* the region center
    node.x = regionCenter.x + (Math.random() - 0.5) * 50; // Adjust range as needed
    node.y = regionCenter.y + (Math.random() - 0.5) * 50;
  } else {
    // Default position if no region found (shouldn't happen with correct data)
    node.x = 400;
    node.y = 300;
  }
});

// --- Tick Function ---
function ticked() {
    link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
}
// --- Interactivity (Venn -> Network) ---

// Click handler for Venn regions
d3.selectAll(".venn-area").on("click", function(event, d) {
    const selectedSets = d.sets;

      node.style("opacity", n => {
        const nodeGroups = n.group.split('-');
        return selectedSets.every(set => nodeGroups.includes(set)) ? 1 : 0.1;
    });

   link.style("stroke-opacity", l => {
        const sourceGroups = l.source.group.split('-');
        const targetGroups = l.target.group.split('-');

        const sourceMatch = selectedSets.every(set => sourceGroups.includes(set));
        const targetMatch = selectedSets.every(set => targetGroups.includes(set));
        return sourceMatch && targetMatch ? 1 : 0.1
    });
});
// --- Drag Functions ---

function dragstarted(event) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  event.subject.fx = event.subject.x;
  event.subject.fy = event.subject.y;
}

function dragged(event) {
  event.subject.fx = event.x;
  event.subject.fy = event.y;
}

function dragended(event) {
  if (!event.active) simulation.alphaTarget(0);
  event.subject.fx = null;
  event.subject.fy = null;
}

</script>

</body>
</html>

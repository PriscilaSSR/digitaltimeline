<!DOCTYPE html>
<html>
<head>
  <title>Flight History: Venn Diagram & Network Graph</title>
  <style>
    .venn-circle { opacity: 0.5; }
    .venn-label { font-family: sans-serif; font-size: 14px; text-anchor: middle; pointer-events: none; /* Prevent text from interfering with clicks */}
    .node { stroke: #fff; stroke-width: 1.5px; }
    .link { stroke: #999; stroke-opacity: 0.6; }
    #tooltip {
        position: absolute;
        background-color: white;
        border: 1px solid black;
        padding: 5px;
        font-family: sans-serif;
        font-size: 12px;
        pointer-events: none; /* Important! */
        display: none; /* Initially hidden */
    }
  </style>
</head>
<body>

<div id="tooltip"></div>
<svg width="800" height="600" id="visualization"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/venn.js/0.2.20/venn.min.js"></script>
<script src="timelineData.js"></script>
 <script>

// --- Venn Diagram ---

// Prepare data for Venn.js
const vennData = [
  { sets: ['SF'], size: 0, label: 'Sociocultural Factors' }, // Start with size 0
  { sets: ['CSB'], size: 0, label: 'Conceptual & Scientific Breakthroughs' },
  { sets: ['EED'], size: 0, label: 'Engineering Experiments & Demonstrations' },
  { sets: ['SF', 'CSB'], size: 0, label: 'SF ∩ CSB' },
  { sets: ['CSB', 'EED'], size: 0, label: 'CSB ∩ EED' },
  { sets: ['SF', 'EED'], size: 0, label: 'SF ∩ EED' },
  { sets: ['SF', 'CSB', 'EED'], size: 0, label: 'SF ∩ CSB ∩ EED' },
];

// Count the number of items in each Venn region
timelineItems.forEach(item => {
    const groups = item.group.split('-'); // Handle items in multiple groups
    let region = null;
        if (groups.length === 1) {
            region = vennData.find(r => r.sets.length === 1 && r.sets[0] === item.group);
        }
    else if(groups.length === 2){
        region = vennData.find(r => r.sets.length === 2 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]));
    }
        else if(groups.length === 3){
            region = vennData.find(r => r.sets.length === 3 && r.sets.includes(groups[0]) && r.sets.includes(groups[1]) && r.sets.includes(groups[2]));
        }


  if (region) {
    region.size += 1;
  }
});

// Create the Venn diagram
const vennChart = venn.VennDiagram()
  .width(400)
  .height(400);

d3.select("#visualization")
  .datum(vennData)
  .call(vennChart);


// --- Network Graph ---

// 1. Prepare Nodes and Links:
const nodes = timelineItems.map(item => ({
  id: item.title,  // Use title as unique ID
  group: item.group,
  ...item // Include all other properties for tooltips, etc.
}));

const links = [];
timelineItems.forEach(item => {
  if (item.connections) {
    item.connections.forEach(target => {
      // Check if the target node exists (avoids errors with typos)
      if (nodes.find(n => n.id === target)) {
        links.push({ source: item.title, target: target, value: 1 }); // You can adjust 'value'
      } else {
        console.warn(`Connection target not found: ${target} from ${item.title}`);
      }
    });
  }
});


// 2. Create SVG and Simulation:
const svg = d3.select("#visualization")
    .append("g"); // Group for the network graph, separate from Venn

const simulation = d3.forceSimulation(nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(50)) // Increased distance
  .force("charge", d3.forceManyBody().strength(-50)) //Moderate repulsion
  .force("center", d3.forceCenter(650, 300))  // Center *next to* the Venn
    .force("collision", d3.forceCollide().radius(15));

// 3. Create Links (Lines):
const link = svg.append("g")
  .attr("class", "links")
  .selectAll("line")
  .data(links)
  .enter().append("line")
  .attr("class", "link")
  .attr("stroke-width", d => Math.sqrt(d.value));

// 4. Create Nodes (Circles):
const node = svg.append("g")
  .attr("class", "nodes")
  .selectAll("circle")
  .data(nodes)
  .enter().append("circle")
  .attr("class", "node")
  .attr("r", 8) // Increased radius
  .attr("fill", d => {
        const groups = d.group.split('-');
        if (groups.includes('SF')) return "red";
        if (groups.includes('CSB')) return "blue";
        if (groups.includes('EED')) return "green";
        return "gray";
    })
  .call(d3.drag()  // D3's built-in drag handling
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

// 5. Add Tooltips:
const tooltip = d3.select("#tooltip");

node.on("mouseover", (event, d) => {
    tooltip.style("display", "block")
           .html(`
               <strong>${d.title}</strong><br>
               Date: ${d.date}<br>
               Category: ${d.category}<br>
               Description: ${d.description}
           `)
           .style("left", (event.pageX + 10) + "px")
           .style("top", (event.pageY - 28) + "px");

    // Highlight connected nodes
    const connectedNodeIds = new Set();
    links.forEach(l => {
      if (l.source.id === d.id) connectedNodeIds.add(l.target.id);
      if (l.target.id === d.id) connectedNodeIds.add(l.source.id);
    });

    node.style("opacity", n => connectedNodeIds.has(n.id) || n.id === d.id ? 1 : 0.2);
    link.style("stroke-opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.1);
  })
  .on("mouseout", () => {
    tooltip.style("display", "none");
    node.style("opacity", 1); // Reset opacity on mouseout
    link.style("stroke-opacity", 0.6);
  });



// 6. Update Positions on Tick:
simulation.on("tick", () => {
  link
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

  node
    .attr("cx", d => d.x)
    .attr("cy", d => d.y);
});



// --- Interactivity (Venn -> Network) ---

// Add click handlers to Venn regions
d3.selectAll(".venn-area").on("click", function(event, d) {
    const selectedSets = d.sets;

    // Filter nodes based on the selected Venn region
    node.style("opacity", n => {
        const nodeGroups = n.group.split('-'); // Handle multiple groups
        // Check if *any* of the node's groups are in the selected sets
        return selectedSets.every(set => nodeGroups.includes(set)) ? 1 : 0.1;
    });

   link.style("stroke-opacity", l => {
        const sourceGroups = l.source.group.split('-');
        const targetGroups = l.target.group.split('-');

        const sourceMatch = selectedSets.every(set => sourceGroups.includes(set));
        const targetMatch = selectedSets.every(set => targetGroups.includes(set));
        return sourceMatch && targetMatch ? 1 : 0.1
    });
});


// --- Drag Functions ---

function dragstarted(event) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  event.subject.fx = event.subject.x;
  event.subject.fy = event.subject.y;
}

function dragged(event) {
  event.subject.fx = event.x;
  event.subject.fy = event.y;
}

function dragended(event) {
  if (!event.active) simulation.alphaTarget(0);
  event.subject.fx = null;
  event.subject.fy = null;
}

</script>

</body>
</html>

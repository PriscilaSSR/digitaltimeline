<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviation Technology Timeline</title>
    <style>
        /* Basic Reset & Font */
        html, body {
            font-family: 'Inter', Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%; /* Ensure html and body take full height */
            width: 100%;
            overflow: hidden; /* Prevent body scroll */
            background-color: #f0f4f8; /* Background color for any small gaps */
            touch-action: none; /* Prevent default touch actions */
        }

        /* Main Title Styling (Floating) */
        #main-title {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            z-index: 90; /* Same level as legend */
            margin: 0; /* Reset default h1 margin */
            font-size: 1.1rem; /* Smaller font size for floating title */
            font-weight: 600;
            color: #343a40;
            cursor: grab; /* Indicate draggability */
            border: 1px solid #dee2e6;
        }

        /* Main container for chart and sidebar */
        .main-container {
            position: relative; /* Keep relative for absolute children */
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            overflow: hidden; /* Crucial for containing SVG and preventing overflow */
            background-color: #ffffff; /* White background for the container */
             border-radius: 0px; /* No rounded corners for full screen */
             box-shadow: none; /* No shadow for full screen */
        }

        /* Chart container */
        #chart-container {
            width: 100%;
            height: 100%;
            display: flex; /* Use flex to center SVG if needed */
            justify-content: center;
            align-items: center;
            cursor: default; /* Default cursor */
            position: relative; /* Needed for absolute positioning of controls */
            overflow: hidden; /* Clip SVG content if it overflows due to pan */
        }

        /* SVG Styling */
        #chart-container svg {
            display: block; /* Remove extra space below SVG */
            width: 100%;
            height: 100%;
        }

        /* Sidebar Styling */
        .sidebar {
            position: absolute;
            top: 0;
            left: -350px; /* Start hidden */
            height: 100%;
            width: 350px;
            max-width: 90%;
            overflow-y: auto;
            background-color: #f8f9fa;
            border-radius: 0 8px 8px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: left 0.3s ease-in-out;
            z-index: 100;
            border-left: 1px solid #dee2e6;
        }
        .sidebar.active {
            left: 0;
        }
        .sidebar-content {
            padding: 25px;
            position: relative;
        }
        .sidebar-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background-color: #e9ecef;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-weight: bold;
            border: none;
            font-size: 18px;
            color: #495057;
        }
        .sidebar-close:hover {
            background-color: #ced4da;
            transform: rotate(90deg);
        }
        .sidebar-image {
            width: 100%;
            height: auto;
            max-height: 200px;
            object-fit: cover;
            margin-bottom: 15px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        .sidebar-title {
            font-size: 1.6rem;
            margin-bottom: 10px;
            padding-right: 40px;
            color: #212529;
            font-weight: 600;
        }
        .sidebar-subtitle {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #495057;
            font-weight: 500;
        }
        .sidebar-text {
            line-height: 1.7;
            margin-bottom: 20px;
            color: #343a40;
            font-size: 0.95rem;
        }

        /* Chart Segment Styling */
        .segment {
            cursor: pointer;
            transition: opacity 0.2s ease-in-out, filter 0.2s ease-in-out;
            stroke: rgba(0,0,0,0.1);
            stroke-width: 0.5px;
        }
        .segment:hover {
            opacity: 0.85;
            filter: brightness(1.1);
        }

        /* Tooltip Styling */
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            font-size: 0.85rem;
            z-index: 110;
            white-space: nowrap;
        }

        /* Legend Styling */
        .legend {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 0px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 0;
            max-width: 280px;
            max-height: 70vh;
            z-index: 90;
            right: 20px;
            bottom: 20px;
            transition: opacity 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid #dee2e6;
        }
        .legend-drag-handle {
            cursor: move;
            width: 100%;
            height: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f1f3f5;
            border-bottom: 1px solid #dee2e6;
            border-radius: 8px 8px 0 0;
            box-sizing: border-box;
        }
        .legend-drag-handle:before {
            content: "";
            width: 40px;
            height: 5px;
            background-color: #adb5bd;
            border-radius: 3px;
        }
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            box-sizing: border-box;
            border-bottom: 1px solid #e9ecef;
        }
        .legend-title {
            font-weight: 600;
            font-size: 1rem;
            margin: 0;
            color: #343a40;
        }
        .legend-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: #495057;
            padding: 0 5px;
            line-height: 1;
            transition: color 0.2s, transform 0.2s;
        }
        .legend-toggle:hover {
            color: #212529;
            transform: scale(1.1);
        }
        .legend-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            padding: 12px;
            box-sizing: border-box;
            max-height: calc(70vh - 80px);
            overflow-y: auto;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding 0.3s ease-in-out;
        }
        .legend-category {
            margin-top: 5px;
            margin-bottom: 3px;
            font-weight: 600;
            font-size: 0.9rem;
            color: #0056b3;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
        }
        .legend-category:first-child {
            margin-top: 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: #495057;
        }
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            flex-shrink: 0;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .legend-content.legend-minimized {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
            border-top: none;
        }

        /* Sidebar Tab Styling */
        .content-tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            gap: 8px;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }
        .tab-button {
            padding: 8px 15px;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .tab-button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        .tab-button:hover:not(.active) {
            background-color: #ced4da;
            border-color: #adb5bd;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Arrow Styling */
        .arrow {
            filter: drop-shadow(0px 1px 1.5px rgba(0,0,0,0.2));
            transition: transform 0.2s ease-in-out;
             /* No hover effect defined */
        }
        /* REMOVED HOVER EFFECT */
        /*
        .connector-group:hover .arrow {
             transform: scale(1.1) translateY(-1px);
        }
        */
        .connector {} /* Connector class no longer used */

        /* Zoom Controls Styling */
        .zoom-controls {
            position: absolute;
            right: 20px;
            top: 20px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .zoom-button {
            width: 40px;
            height: 40px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50%;
            border: 1px solid #ced4da;
            background-color: white;
            color: #495057;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        .zoom-button:hover {
            background-color: #f1f3f5;
            border-color: #adb5bd;
        }
        .zoom-button:active {
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            transform: scale(0.95);
        }

        /* Zoom Indicator Styling */
        #zoom-indicator {
            position: absolute;
            left: 20px;
            bottom: 20px;
            padding: 6px 12px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            z-index: 50;
            pointer-events: none;
        }

        /* Label Styling */
        .label-group text {
           pointer-events: none;
           font-weight: bold;
           font-size: 12px;
           fill: #fff;
        }
        .label-group .label-shadow {
           stroke: rgba(0,0,0,0.6);
           stroke-width: 3px;
           stroke-linejoin: round;
           fill: none;
        }

    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <h1 id="main-title">Interactive Aviation Timeline</h1>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-content" id="sidebar-content">
                </div>
        </div>

        <div id="chart-container">
             </div>

        <div class="zoom-controls" id="zoom-controls">
            </div>

        <div id="zoom-indicator">Zoom: 100%</div>
    </div>

    <div class="legend" id="legend">
         </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // --- Configuration ---
        let config = {}; // Initialize config, will be populated later
        let scaleFactor = 1; // To store the scaling factor
        let gapSize = 15; // Base gap size in pixels, will be scaled (Increased slightly)

        // --- State Variables ---
        let currentZoom = 1;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let isPanning = false;
        let lastPointerX = 0; // Use generic pointer coordinates
        let lastPointerY = 0;
        let initialPinchDistance = 0; // For pinch zoom

        // --- DOM Elements (cache them) ---
        let chartContainer, svgElement, chartGroup, sidebar, sidebarContent, tooltip, legendContainer, zoomIndicator, mainTitleElement; // Added mainTitleElement

        // --- Placeholder Image Handling ---
        const placeholderBase = "https://placehold.co";
        function getPlaceholderUrl(width = 400, height = 250, text = "Image") {
            return `${placeholderBase}/${width}x${height}/EBF0F5/777?text=${encodeURIComponent(text)}`;
        }
        function handleImageError(imgElement) {
            console.warn(`Image failed to load: ${imgElement.src}. Using placeholder.`);
            imgElement.src = getPlaceholderUrl(300, 180, 'Not Found');
            imgElement.onerror = null; // Prevent infinite loop if placeholder fails
        }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Cache DOM elements
            chartContainer = document.getElementById('chart-container');
            sidebar = document.getElementById('sidebar');
            sidebarContent = document.getElementById('sidebar-content');
            tooltip = document.getElementById('tooltip');
            legendContainer = document.getElementById('legend');
            zoomIndicator = document.getElementById('zoom-indicator');
            mainTitleElement = document.getElementById('main-title'); // Cache title

            // Initial setup
            initializeConfig(); // Setup initial config data
            createChart();      // Create the SVG chart
            addZoomControls();  // Add UI buttons
            setupEventListeners(); // Setup zoom, pan, click, resize listeners

            // Apply initial transform state (usually 1, 0, 0)
            applyTransform();

            // Make the main title draggable
            if (mainTitleElement) {
                makeDraggable(mainTitleElement); // Make title draggable (no specific handle)
            }
        });

        // --- Configuration Setup ---
        function initializeConfig() {
            const dimensions = getResponsiveDimensions(); // Initial dimensions
            config = {
                ...dimensions, // width, height, chartSize, centerX, centerY
                rings: [ // Define rings with base radius
                    { name: "Dream of Flight", radius: 200, color: "#8A2BE2", segments: 3, segmentNames: ["Ancient Times (Myth & Early Ideas)", "Renaissance to Enlightenment (Concepts)", "Early Experiments (18th-19th C)"], segmentContent: [ { title: "Dream of Flight", subtitle: "Ancient Times (Myth & Early Ideas)", content: [ { title: "Icarus & Daedalus", subtitle: "c. 500s BCE (Myth)", text: "The Greek myth of Icarus and Daedalus flying with wax and feather wings embodies humanity's earliest recorded aspirations and cautionary tales about flight.", imageSrc: getPlaceholderUrl(400, 250, 'Icarus Myth') }, { title: "Kites in China", subtitle: "c. 400s BCE", text: "Early kites in China demonstrated an understanding of aerodynamic principles and were used for signaling, measuring distances, and even testing wind.", imageSrc: getPlaceholderUrl(400, 250, 'Ancient Kite') }, ] }, { title: "Dream of Flight", subtitle: "Renaissance to Enlightenment (Concepts)", content: [ { title: "Leonardo da Vinci", subtitle: "c. 1500 CE", text: "Da Vinci's detailed sketches of flying machines (ornithopters, helicopters, gliders) based on bird flight marked a shift towards scientific observation, though none were built.", imageSrc: getPlaceholderUrl(400, 250, 'Da Vinci Sketch') }, { title: "Newton's Laws", subtitle: "1687 CE", text: "Isaac Newton's laws of motion and universal gravitation provided the fundamental physics principles necessary for understanding lift and flight dynamics.", imageSrc: getPlaceholderUrl(400, 250, 'Newton Laws') }, ] }, { title: "Dream of Flight", subtitle: "Early Experiments (18th-19th C)", content: [ { title: "Montgolfier Brothers", subtitle: "1783 CE", text: "The Montgolfier brothers achieved the first untethered human flight in a hot air balloon, demonstrating lighter-than-air flight.", imageSrc: getPlaceholderUrl(400, 250, 'Montgolfier Balloon') }, { title: "Sir George Cayley", subtitle: "Early 1800s CE", text: "Often called the 'Father of Aviation', Cayley identified the four forces of flight (lift, drag, thrust, weight) and designed early gliders, separating lift and propulsion.", imageSrc: getPlaceholderUrl(400, 250, 'Cayley Glider') }, ] } ] },
                    { name: "Connector 1", color: "#7D59D9", isConnector: true, arrowCount: 8, thickness: 7 }, // Connector definition
                    { name: "Powered Flight Era", radius: 150, color: "#4169E1", segments: 4, segmentNames: ["Pioneers (1900s-1910s)", "World War I (1914-1918)", "Golden Age (1920s-1930s)", "World War II (1939-1945)"], segmentContent: [ { title: "Powered Flight Era", subtitle: "Pioneers (1900s-1910s)", content: [ { title: "Wright Brothers", subtitle: "1903 CE", text: "Orville and Wilbur Wright achieved the first sustained, controlled, powered heavier-than-air flight at Kitty Hawk, North Carolina.", imageSrc: getPlaceholderUrl(400, 250, 'Wright Flyer') }, { title: "Louis Blériot", subtitle: "1909 CE", text: "Blériot made the first flight across the English Channel, demonstrating the potential of aircraft for transportation and crossing natural barriers.", imageSrc: getPlaceholderUrl(400, 250, 'Bleriot XI') }, ] }, { title: "Powered Flight Era", subtitle: "World War I (1914-1918)", content: [ { title: "Rapid Advancement", subtitle: "Military Needs", text: "WWI dramatically accelerated aircraft development. Planes evolved from reconnaissance tools to fighters and bombers, with improvements in engines, structures, and armament.", imageSrc: getPlaceholderUrl(400, 250, 'WWI Biplane') }, { title: "Ace Pilots", subtitle: "Air Combat", text: "The era saw the rise of 'ace' pilots like Manfred von Richthofen (Red Baron), popularizing aviation and driving tactical innovation.", imageSrc: getPlaceholderUrl(400, 250, 'Red Baron') }, ] }, { title: "Powered Flight Era", subtitle: "Golden Age (1920s-1930s)", content: [ { title: "Air Mail & Airlines", subtitle: "Commercial Growth", text: "Barnstorming, air races, and the establishment of air mail routes fueled public interest and led to the formation of the first passenger airlines.", imageSrc: getPlaceholderUrl(400, 250, 'Ford Trimotor') }, { title: "Lindbergh's Flight", subtitle: "1927 CE", text: "Charles Lindbergh's solo non-stop flight across the Atlantic Ocean captivated the world and symbolized the potential of long-distance aviation.", imageSrc: getPlaceholderUrl(400, 250, 'Spirit of St Louis') }, { title: "Amelia Earhart", subtitle: "Record Breaking", text: "Amelia Earhart became a global icon, breaking numerous aviation records and advocating for women in aviation.", imageSrc: getPlaceholderUrl(400, 250, 'Amelia Earhart') }, ] }, { title: "Powered Flight Era", subtitle: "World War II (1939-1945)", content: [ { title: "Mass Production", subtitle: "Industrial Scale", text: "WWII saw unprecedented mass production of aircraft like the B-17 Flying Fortress and P-51 Mustang. Strategic bombing and carrier operations became crucial.", imageSrc: getPlaceholderUrl(400, 250, 'B-17 Bomber') }, { title: "Jet Engine Emergence", subtitle: "New Propulsion", text: "Germany and Britain developed the first operational jet aircraft (Me 262, Gloster Meteor) near the war's end, heralding a new era of speed.", imageSrc: getPlaceholderUrl(400, 250, 'Me 262 Jet') }, ] } ] },
                    { name: "Connector 2", color: "#3A98B9", isConnector: true, arrowCount: 6, thickness: 7 }, // Connector definition
                    { name: "Jet Age & Space Race", radius: 100, color: "#32CD32", segments: 3, segmentNames: ["Early Jet Age (1945-1960s)", "Supersonic & Jumbo Jets (1960s-1970s)", "Modern Aviation (1980s-Present)"], segmentContent: [ { title: "Jet Age & Space Race", subtitle: "Early Jet Age (1945-1960s)", content: [ { title: "Breaking Sound Barrier", subtitle: "1947 CE", text: "Chuck Yeager, piloting the Bell X-1, became the first human to officially break the sound barrier in level flight.", imageSrc: getPlaceholderUrl(400, 250, 'Bell X-1') }, { title: "Jet Airliners", subtitle: "De Havilland Comet, Boeing 707", text: "The introduction of jet airliners like the Comet and 707 revolutionized air travel, making it faster and more accessible.", imageSrc: getPlaceholderUrl(400, 250, 'Boeing 707') }, { title: "Space Race Begins", subtitle: "Sputnik & NASA", text: "The launch of Sputnik (1957) and the formation of NASA (1958) marked the beginning of the space race, heavily influencing aerospace technology.", imageSrc: getPlaceholderUrl(400, 250, 'Sputnik') }, ] }, { title: "Jet Age & Space Race", subtitle: "Supersonic & Jumbo Jets (1960s-1970s)", content: [ { title: "Apollo Moon Landing", subtitle: "1969 CE", text: "The Apollo 11 mission successfully landed humans on the Moon, a monumental achievement in aerospace engineering.", imageSrc: getPlaceholderUrl(400, 250, 'Apollo 11') }, { title: "Boeing 747 'Jumbo Jet'", subtitle: "1969 CE", text: "The arrival of the wide-body Boeing 747 significantly increased passenger capacity and lowered airfare costs, enabling mass air travel.", imageSrc: getPlaceholderUrl(400, 250, 'Boeing 747') }, { title: "Concorde SST", subtitle: "1976 CE", text: "The Concorde offered supersonic passenger travel, though its high operating costs and environmental concerns limited its success.", imageSrc: getPlaceholderUrl(400, 250, 'Concorde') }, ] }, { title: "Jet Age & Space Race", subtitle: "Modern Aviation (1980s-Present)", content: [ { title: "Fly-by-Wire & Composites", subtitle: "Airbus A320, Boeing 777/787", text: "Advanced digital flight controls (fly-by-wire) and the use of lightweight composite materials improved efficiency and performance.", imageSrc: getPlaceholderUrl(400, 250, 'Airbus A320 Cockpit') }, { title: "GPS Navigation", subtitle: "Satellite Tech", text: "Global Positioning System (GPS) revolutionized navigation, making flights safer and more direct.", imageSrc: getPlaceholderUrl(400, 250, 'GPS Satellite') }, { title: "UAVs / Drones", subtitle: "Unmanned Systems", text: "The development and proliferation of Unmanned Aerial Vehicles (drones) have created new applications in military, commercial, and recreational sectors.", imageSrc: getPlaceholderUrl(400, 250, 'Drone') }, ] } ] },
                    { name: "Connector 3", color: "#91B93A", isConnector: true, arrowCount: 5, thickness: 6 }, // Connector definition
                    { name: "Future of Flight", radius: 50, color: "#FF7F50", segments: 1, segmentNames: ["Emerging Technologies"], segmentContent: [ { title: "Future of Flight", subtitle: "Emerging Technologies", content: [ { title: "Sustainable Aviation", subtitle: "Electric & Hydrogen", text: "Focus on reducing environmental impact through electric propulsion, hydrogen fuel, and sustainable aviation fuels (SAFs).", imageSrc: getPlaceholderUrl(400, 250, 'Electric Plane Concept') }, { title: "Urban Air Mobility", subtitle: "eVTOLs", text: "Development of electric Vertical Takeoff and Landing (eVTOL) aircraft aims to provide short-distance urban air transportation.", imageSrc: getPlaceholderUrl(400, 250, 'eVTOL Concept') }, { title: "Hypersonic Travel", subtitle: "Mach 5+", text: "Research into hypersonic flight promises drastically reduced travel times for long-distance journeys.", imageSrc: getPlaceholderUrl(400, 250, 'Hypersonic Concept') }, { title: "Space Tourism", subtitle: "Commercial Spaceflight", text: "Companies are developing reusable rockets and spacecraft to make space travel accessible for tourism and commercial purposes.", imageSrc: getPlaceholderUrl(400, 250, 'Space Tourism Rocket') }, ] } ] }
                ]
            };
             // Calculate scale factor and gap size based on initial dimensions
             calculateScaleAndGap();
        }

        // --- Responsive Dimensions & Scaling ---
        function getResponsiveDimensions() {
            const containerWidth = chartContainer.clientWidth;
            const containerHeight = chartContainer.clientHeight;
            const padding = Math.min(containerWidth, containerHeight) * 0.04;
            const size = Math.min(containerWidth - 2 * padding, containerHeight - 2 * padding);
            return {
                width: containerWidth, height: containerHeight, chartSize: size,
                centerX: containerWidth / 2, centerY: containerHeight / 2,
            };
        }

        function calculateScaleAndGap() {
             const baseOuterRadius = config.rings[0].radius; // Use the outermost ring's base radius
             if (baseOuterRadius <= 0) { // Prevent division by zero
                 scaleFactor = 1;
             } else {
                 scaleFactor = config.chartSize / 2 / baseOuterRadius;
             }
             // Define gap size relative to scale factor (e.g., 15px at base size)
             gapSize = Math.max(5, 15 * scaleFactor); // Ensure a minimum gap, increased base gap
        }

        // --- Chart Creation (Corrected Logic) ---
        function createChart() {
            // Update dimensions and recalculate scale/gap
            const dimensions = getResponsiveDimensions();
            config = { ...config, ...dimensions };
            calculateScaleAndGap(); // Recalculate scale and gap based on new dimensions

            // Clear previous SVG
            chartContainer.innerHTML = '';
            svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgElement.setAttribute("viewBox", `0 0 ${config.width} ${config.height}`);
            svgElement.setAttribute("width", "100%");
            svgElement.setAttribute("height", "100%");
            svgElement.style.backgroundColor = "#ffffff";
            chartContainer.appendChild(svgElement);

            // Create the main group for transformations
            chartGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            svgElement.appendChild(chartGroup);

            // --- Pre-calculate Scaled Radii for Content Rings ---
            config.rings.forEach(ring => {
                if (!ring.isConnector) {
                    ring.scaledRadius = ring.radius * scaleFactor;
                }
            });

            // --- Draw Content Rings and Arrows ---
            let currentContentRingIndex = -1;
            config.rings.forEach((ring, index) => {
                if (!ring.isConnector) {
                    // --- Draw Content Ring ---
                    currentContentRingIndex++;
                    const outerR = ring.scaledRadius;

                    // Find the *next* content ring to determine the inner boundary
                    let nextContentRing = null;
                    for (let j = index + 1; j < config.rings.length; j++) {
                        if (!config.rings[j].isConnector) {
                            nextContentRing = config.rings[j];
                            break;
                        }
                    }

                    // Determine the inner radius for drawing, leaving a gap
                    let innerR = 0; // Default for innermost
                    if (nextContentRing) {
                        innerR = nextContentRing.scaledRadius + gapSize;
                    } else if (ring.segments > 1) { // Innermost multi-segment ring
                        innerR = outerR * 0.1; // Small hole
                    } // Else: Innermost single segment ring, innerR remains 0 (solid circle)

                    // Ensure inner radius is valid
                    innerR = Math.max(0, Math.min(innerR, outerR - 1));

                    // Draw the segments for this content ring
                    createContentRingSegments(ring, innerR, outerR, chartGroup);

                } else {
                    // --- Draw Arrows in Gap ---
                    // Find the previous and next content rings
                    const prevContentRing = config.rings[index - 1]; // Assumes connector is never first
                    let nextContentRing = null;
                    for (let j = index + 1; j < config.rings.length; j++) {
                        if (!config.rings[j].isConnector) {
                            nextContentRing = config.rings[j];
                            break;
                        }
                    }

                    if (prevContentRing && nextContentRing) {
                        // Calculate the radius for placing arrows (middle of the gap)
                        // Gap is between nextContentRing.scaledRadius and (nextContentRing.scaledRadius + gapSize)
                        const arrowPlacementRadius = nextContentRing.scaledRadius + (gapSize / 2);

                        // Draw the arrows using the connector definition (color, count)
                        createArrowsInGap(ring, arrowPlacementRadius, gapSize, chartGroup);
                    }
                }
            });

            // Create legend and apply transform
            createFloatingLegend();
            applyTransform();
        }

        // --- Create Content Ring Segments (Takes Inner/Outer Radii) ---
        function createContentRingSegments(ring, innerRadius, outerRadius, parent) {
            const segmentAngle = 360 / ring.segments;

            for (let i = 0; i < ring.segments; i++) {
                const startAngle = i * segmentAngle;
                const endAngle = (i + 1) * segmentAngle;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", describeArc(config.centerX, config.centerY, innerRadius, outerRadius, startAngle, endAngle));
                path.setAttribute("fill", ring.color);
                path.classList.add("segment");
                path.dataset.name = ring.segmentNames[i];
                path.dataset.ring = ring.name;
                path.dataset.ringIndex = config.rings.indexOf(ring); // Store original index
                path.dataset.segmentIndex = i;

                if (ring.segments > 1) {
                     const brightness = 1 + (i % 2 === 0 ? 0.05 : -0.05);
                     path.style.filter = `brightness(${brightness})`;
                }

                path.addEventListener("pointermove", handlePointerMove);
                path.addEventListener("pointerleave", handlePointerLeave);
                path.addEventListener("click", handleSegmentClick);
                parent.appendChild(path);

                // Add label (pass calculated inner/outer radii for sizing)
                addSegmentLabel(ring, i, innerRadius, outerRadius, startAngle, endAngle, parent);
            }
        }

        // --- Create Arrows In Gap (Draws only arrows) ---
        function createArrowsInGap(connectorDef, placementRadius, currentGapSize, parent) {
            const arrowCount = connectorDef.arrowCount || 6;
            const arrowColor = connectorDef.color;

            // Adjust arrow size based on the gap size
            const arrowLength = currentGapSize * 0.7; // Arrow length relative to gap
            const arrowWidth = currentGapSize * 0.5;  // Arrow width relative to gap

            const connectorGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            connectorGroup.classList.add("connector-group"); // Keep class for potential styling/hover

            for (let i = 0; i < arrowCount; i++) {
                const angleDeg = (i * 360 / arrowCount);
                const angleRad = (angleDeg - 90) * Math.PI / 180.0;

                // Calculate points centered around the placementRadius
                const tip = polarToCartesian(config.centerX, config.centerY, placementRadius - arrowLength / 2, angleDeg);
                const baseCenter = polarToCartesian(config.centerX, config.centerY, placementRadius + arrowLength / 2, angleDeg);

                const perpAngleRad = angleRad + Math.PI / 2;
                const wingOffset = arrowWidth / 2;
                const wing1X = baseCenter.x + wingOffset * Math.cos(perpAngleRad);
                const wing1Y = baseCenter.y + wingOffset * Math.sin(perpAngleRad);
                const wing2X = baseCenter.x - wingOffset * Math.cos(perpAngleRad);
                const wing2Y = baseCenter.y - wingOffset * Math.sin(perpAngleRad);

                const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                arrow.setAttribute("points", `${wing1X},${wing1Y} ${wing2X},${wing2Y} ${tip.x},${tip.y}`);
                arrow.setAttribute("fill", arrowColor);
                arrow.classList.add("arrow");
                connectorGroup.appendChild(arrow);
            }
            parent.appendChild(connectorGroup);
        }


        // --- Helper to Describe SVG Arc Path (Unchanged) ---
        function describeArc(x, y, innerRadius, outerRadius, startAngle, endAngle) {
            innerRadius = Math.max(0, innerRadius); // Ensure inner radius isn't negative
            outerRadius = Math.max(innerRadius + 0.1, outerRadius); // Ensure outer radius is larger

            const startOuter = polarToCartesian(x, y, outerRadius, endAngle);
            const endOuter = polarToCartesian(x, y, outerRadius, startAngle);
            const startInner = polarToCartesian(x, y, innerRadius, endAngle);
            const endInner = polarToCartesian(x, y, innerRadius, startAngle);

            const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

            // Handle full circle case (or near full circle)
            if (Math.abs(endAngle - startAngle) >= 359.99) {
                 const midAngle = startAngle + 180;
                 const midOuter1 = polarToCartesian(x, y, outerRadius, midAngle);
                 const midInner1 = polarToCartesian(x, y, innerRadius, midAngle);
                 const midOuter2 = polarToCartesian(x, y, outerRadius, startAngle);
                 const midInner2 = polarToCartesian(x, y, innerRadius, startAngle);
                 const d = [ "M", startOuter.x, startOuter.y, "A", outerRadius, outerRadius, 0, 0, 0, midOuter1.x, midOuter1.y, "L", midInner1.x, midInner1.y, "A", innerRadius, innerRadius, 0, 0, 1, startInner.x, startInner.y, "Z", "M", midOuter1.x, midOuter1.y, "A", outerRadius, outerRadius, 0, 0, 0, midOuter2.x, midOuter2.y, "L", midInner2.x, midInner2.y, "A", innerRadius, innerRadius, 0, 0, 1, midInner1.x, midInner1.y, "Z" ].join(" ");
                 return d;
            }
            const d = [ "M", startOuter.x, startOuter.y, "A", outerRadius, outerRadius, 0, largeArcFlag, 0, endOuter.x, endOuter.y, "L", endInner.x, endInner.y, "A", innerRadius, innerRadius, 0, largeArcFlag, 1, startInner.x, startInner.y, "Z" ].join(" ");
            return d;
        }

        // --- Helper: Polar to Cartesian Coordinates (Unchanged) ---
        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(angleInRadians)),
                y: centerY + (radius * Math.sin(angleInRadians))
            };
        }

        // --- Add Segment Label (Unchanged, uses passed inner/outer radii) ---
        function addSegmentLabel(ring, segmentIndex, innerR, outerR, startAng, endAng, parent) {
            const angleSpan = endAng - startAng;
            const radiusSpan = outerR - innerR;
            if (radiusSpan < 20 || angleSpan < 15) return;
            const midAngle = startAng + angleSpan / 2;
            const textRadius = innerR + radiusSpan * 0.6;
            const pos = polarToCartesian(config.centerX, config.centerY, textRadius, midAngle);
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", pos.x);
            text.setAttribute("y", pos.y);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.style.fontSize = `${Math.min(14, Math.max(8, radiusSpan / 3.5))}px`;
            text.textContent = ring.segmentNames[segmentIndex];
            let rotation = midAngle;
            if (rotation > 90 && rotation < 270) { rotation += 180; }
            text.setAttribute("transform", `rotate(${rotation}, ${pos.x}, ${pos.y})`);
            const labelGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            labelGroup.classList.add("label-group");
            const textShadow = text.cloneNode(true);
            textShadow.classList.add("label-shadow");
            textShadow.style.fill = 'none';
            textShadow.style.stroke = 'rgba(0,0,0,0.6)';
            textShadow.style.strokeWidth = '3px';
            textShadow.style.strokeLinejoin = 'round';
            labelGroup.appendChild(textShadow);
            labelGroup.appendChild(text);
            parent.appendChild(labelGroup);
        }

        // --- Legend Creation (Unchanged) ---
        function createFloatingLegend() {
            legendContainer.innerHTML = '';
            legendContainer.className = 'legend';
            const dragHandle = document.createElement('div');
            dragHandle.className = 'legend-drag-handle';
            legendContainer.appendChild(dragHandle);
            const header = document.createElement('div');
            header.className = 'legend-header';
            const title = document.createElement('h3');
            title.className = 'legend-title';
            title.textContent = 'Legend';
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'legend-toggle';
            toggleBtn.innerHTML = '&minus;';
            toggleBtn.title = 'Minimize/Maximize Legend';
            header.appendChild(title);
            header.appendChild(toggleBtn);
            legendContainer.appendChild(header);
            const content = document.createElement('div');
            content.className = 'legend-content';
            legendContainer.appendChild(content);
            const ringGroups = {};
            config.rings.forEach((ring, ringIndex) => {
                if (ring.isConnector) return;
                if (!ringGroups[ring.name]) { ringGroups[ring.name] = []; }
                ring.segmentNames.forEach((name, i) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = ring.color;
                    if (ring.segments > 1) {
                        const brightness = 1 + (i % 2 === 0 ? 0.05 : -0.05);
                        colorBox.style.filter = `brightness(${brightness})`;
                    }
                    const label = document.createElement('span');
                    label.textContent = name;
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    ringGroups[ring.name].push(item);
                });
            });
            for (const ringName in ringGroups) {
                const categoryTitle = document.createElement('div');
                categoryTitle.className = 'legend-category';
                categoryTitle.textContent = ringName;
                content.appendChild(categoryTitle);
                ringGroups[ringName].forEach(item => { content.appendChild(item); });
            }
            toggleBtn.addEventListener('click', function() {
                content.classList.toggle('legend-minimized');
                this.innerHTML = content.classList.contains('legend-minimized') ? '&plus;' : '&minus;';
                if (!content.classList.contains('legend-minimized')) {
                    content.style.maxHeight = 'calc(70vh - 80px)';
                }
            });
            makeDraggable(legendContainer, dragHandle);
        }

        // --- Draggable Element Functionality (Unchanged) ---
        function makeDraggable(element, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const dragTarget = handle || element;
            dragTarget.onpointerdown = dragPointerDown;
            function dragPointerDown(e) {
                e = e || window.event;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.cursor = 'grabbing';
                document.onpointerup = closeDragElement;
                document.onpointermove = elementDrag;
            }
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                setElementPosition(element, pos1, pos2);
            }
            function setElementPosition(elmnt, p1, p2) {
                const containerRect = document.body.getBoundingClientRect();
                const elmntRect = elmnt.getBoundingClientRect();
                let newTop = elmnt.offsetTop - p2;
                let newLeft = elmnt.offsetLeft - p1;
                newTop = Math.max(0, Math.min(newTop, containerRect.height - elmntRect.height));
                newLeft = Math.max(0, Math.min(newLeft, containerRect.width - elmntRect.width));
                elmnt.style.top = newTop + "px";
                elmnt.style.left = newLeft + "px";
                elmnt.style.right = "auto";
                elmnt.style.bottom = "auto";
            }
            function closeDragElement() {
                document.onpointerup = null;
                document.onpointermove = null;
                element.style.cursor = 'grab';
                if (handle) handle.style.cursor = 'move';
            }
             element.style.cursor = 'grab';
             if (handle) handle.style.cursor = 'move';
        }

        // --- Tooltip Handling (Unchanged) ---
        function showTooltip(event, target) {
            tooltip.style.opacity = 1;
            tooltip.style.left = event.pageX + 15 + 'px';
            tooltip.style.top = event.pageY + 15 + 'px';
            tooltip.textContent = `${target.dataset.ring}: ${target.dataset.name}`;
        }
        function hideTooltip() { tooltip.style.opacity = 0; }

        // --- Sidebar Handling (Unchanged) ---
        function showSidebar(ringIndex, segmentIndex) {
            const ring = config.rings[ringIndex]; // Use original index from dataset
            if (!ring || !ring.segmentContent || !ring.segmentContent[segmentIndex]) { console.error("Invalid ring/segment index:", ringIndex, segmentIndex); return; }
            const segmentData = ring.segmentContent[segmentIndex];
            const hasMultipleContent = segmentData.content && Array.isArray(segmentData.content) && segmentData.content.length > 0;
            if (!hasMultipleContent) { console.error("No content array found:", segmentData); return; }
            let contentHTML = `<button class="sidebar-close" id="close-sidebar" aria-label="Close Details">&times;</button><h2 class="sidebar-title">${segmentData.title}</h2><h3 class="sidebar-subtitle">${segmentData.subtitle}</h3>`;
            if (segmentData.content.length > 1) {
                contentHTML += `<div class="content-tabs">`;
                segmentData.content.forEach((item, idx) => { contentHTML += `<button class="tab-button ${idx === 0 ? 'active' : ''}" data-tab="${idx}">${item.title}</button>`; });
                contentHTML += `</div>`;
            }
            contentHTML += `<div class="tab-content">`;
            segmentData.content.forEach((item, idx) => { contentHTML += `<div class="content-section ${idx === 0 ? 'active' : ''}" data-tab="${idx}">${item.imageSrc ? `<img class="sidebar-image" src="${item.imageSrc}" alt="${item.title}" onerror="handleImageError(this)">` : ''}${item.subtitle ? `<h4 class="sidebar-subtitle">${item.subtitle}</h4>` : ''}<p class="sidebar-text">${item.text || 'No description available.'}</p></div>`; });
            contentHTML += `</div>`;
            sidebarContent.innerHTML = contentHTML;
            sidebar.classList.add('active');
            const closeButton = sidebarContent.querySelector('#close-sidebar');
            if (closeButton) { closeButton.addEventListener('click', closeSidebar); }
            const tabButtons = sidebarContent.querySelectorAll('.tab-button');
            if (tabButtons.length > 0) { tabButtons.forEach(button => { button.addEventListener('click', handleTabClick); }); }
            setTimeout(() => { document.addEventListener('click', closeSidebarOnClickOutside); document.addEventListener('keydown', handleEscKey); }, 10);
        }
        function handleTabClick(event) {
            const clickedButton = event.target;
            const tabIndex = clickedButton.getAttribute('data-tab');
            const tabContainer = clickedButton.closest('.sidebar-content');
            tabContainer.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            tabContainer.querySelectorAll('.content-section').forEach(section => section.classList.remove('active'));
            clickedButton.classList.add('active');
            const activeSection = tabContainer.querySelector(`.content-section[data-tab="${tabIndex}"]`);
            if (activeSection) { activeSection.classList.add('active'); }
        }
        function closeSidebar() {
            sidebar.classList.remove('active');
            document.removeEventListener('click', closeSidebarOnClickOutside);
            document.removeEventListener('keydown', handleEscKey);
        }
        function closeSidebarOnClickOutside(event) {
            if (!sidebar.contains(event.target) && !event.target.closest('.segment')) { closeSidebar(); }
        }
        function handleEscKey(event) { if (event.key === "Escape") { closeSidebar(); } }

        // --- Event Handlers Setup (Unchanged) ---
        function setupEventListeners() {
            window.addEventListener('resize', handleResize);
            chartContainer.addEventListener('pointerdown', handlePointerDown);
            chartContainer.addEventListener('wheel', handleWheel, { passive: false });
        }
        function handleResize() { createChart(); applyTransform(); }

        // --- Pointer Event Handlers (Unchanged) ---
        function handlePointerDown(event) {
             if (event.pointerType === 'mouse' && event.button !== 0) return;
             const target = event.target;
             const isBackground = target === chartContainer || target === svgElement || target === chartGroup;
            if (currentZoom > 1 && isBackground) {
                 isPanning = true;
                 lastPointerX = event.clientX;
                 lastPointerY = event.clientY;
                 chartContainer.style.cursor = 'grabbing';
                 chartContainer.setPointerCapture(event.pointerId);
                 document.addEventListener('pointermove', handlePointerMovePan);
                 document.addEventListener('pointerup', handlePointerUp);
                 document.addEventListener('pointercancel', handlePointerUp);
            }
        }
        function handlePointerMove(event) { // For segment hover
            const target = event.target.closest('.segment');
            if (target) { showTooltip(event, target); } else { hideTooltip(); }
        }
        function handlePointerMovePan(event) { // For panning
            if (!isPanning) return;
            const deltaX = event.clientX - lastPointerX;
            const deltaY = event.clientY - lastPointerY;
            lastPointerX = event.clientX;
            lastPointerY = event.clientY;
            panOffsetX += deltaX;
            panOffsetY += deltaY;
            applyTransform();
        }
        function handlePointerLeave(event) { hideTooltip(); } // For segment hover
        function handlePointerUp(event) { // For panning
            if (isPanning) {
                isPanning = false;
                chartContainer.style.cursor = currentZoom > 1 ? 'grab' : 'default';
                chartContainer.releasePointerCapture(event.pointerId);
                document.removeEventListener('pointermove', handlePointerMovePan);
                document.removeEventListener('pointerup', handlePointerUp);
                document.removeEventListener('pointercancel', handlePointerUp);
            }
        }
        function handleSegmentClick(event) {
            if (isPanning) return;
            const target = event.target.closest('.segment');
            // Use original ring index stored in dataset
            if (target && target.dataset.ringIndex !== undefined && target.dataset.segmentIndex !== undefined) {
                const ringIndex = parseInt(target.dataset.ringIndex, 10);
                const segmentIndex = parseInt(target.dataset.segmentIndex, 10);
                 if (!isNaN(ringIndex) && !isNaN(segmentIndex)) { showSidebar(ringIndex, segmentIndex); }
            }
        }

        // --- Zoom Handling (Unchanged) ---
        function handleWheel(event) {
            event.preventDefault();
            const zoomDelta = event.deltaY < 0 ? 0.15 : -0.15;
            const rect = svgElement.getBoundingClientRect();
            const pointerX = event.clientX - rect.left;
            const pointerY = event.clientY - rect.top;
            zoomChartAtPoint(zoomDelta, pointerX, pointerY);
        }
        function addZoomControls() {
            const controlsContainer = document.getElementById('zoom-controls');
            controlsContainer.innerHTML = '';
            const zoomInBtn = document.createElement('button');
            zoomInBtn.innerHTML = '+'; zoomInBtn.className = 'zoom-button'; zoomInBtn.ariaLabel = 'Zoom In';
            zoomInBtn.addEventListener('click', () => zoomChart(0.2));
            const zoomOutBtn = document.createElement('button');
            zoomOutBtn.innerHTML = '-'; zoomOutBtn.className = 'zoom-button'; zoomOutBtn.ariaLabel = 'Zoom Out';
            zoomOutBtn.addEventListener('click', () => zoomChart(-0.2));
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = '&#x21BB;'; resetBtn.className = 'zoom-button'; resetBtn.ariaLabel = 'Reset Zoom';
            resetBtn.addEventListener('click', resetZoomPan);
            controlsContainer.appendChild(zoomInBtn); controlsContainer.appendChild(zoomOutBtn); controlsContainer.appendChild(resetBtn);
        }
        function zoomChart(delta) { // Zooms towards center
            if (!svgElement) return;
            const centerX = config.width / 2; const centerY = config.height / 2;
            zoomChartAtPoint(delta, centerX, centerY);
        }
        function zoomChartAtPoint(zoomDelta, pointX, pointY) {
            const minZoom = 0.2; const maxZoom = 5.0;
            const newZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom + zoomDelta * currentZoom));
            if (newZoom === currentZoom) return;
            const oldZoom = currentZoom; currentZoom = newZoom;
            panOffsetX = pointX - (pointX - panOffsetX) * (currentZoom / oldZoom);
            panOffsetY = pointY - (pointY - panOffsetY) * (currentZoom / oldZoom);
            applyTransform(); updateZoomIndicator();
        }
        function resetZoomPan() {
            currentZoom = 1; panOffsetX = 0; panOffsetY = 0;
            applyTransform(); updateZoomIndicator();
        }

        // --- Apply Transformation (Unchanged) ---
        function applyTransform() {
            if (chartGroup) {
                chartGroup.setAttribute('transform', `translate(${panOffsetX}, ${panOffsetY}) scale(${currentZoom})`);
                if (isPanning) { chartContainer.style.cursor = 'grabbing'; }
                else { chartContainer.style.cursor = currentZoom > 1 ? 'grab' : 'default'; }
            } else { console.error("Chart group not found for applying transform."); }
        }

        // --- Update Zoom Indicator (Unchanged) ---
        let indicatorTimeout;
        function updateZoomIndicator() {
            zoomIndicator.textContent = `Zoom: ${Math.round(currentZoom * 100)}%`;
            zoomIndicator.style.opacity = '1';
            clearTimeout(indicatorTimeout);
            indicatorTimeout = setTimeout(() => { zoomIndicator.style.opacity = '0'; }, 1500);
        }

    </script>
</body>
</html>
